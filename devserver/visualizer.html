<!DOCTYPE html>
<html>
<head>
    <title>Flowchart-style Graph Demo</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        #controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            margin: 5px;
            padding: 8px 16px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #1557b0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="addRandomNode()">Add Node</button>
        <button onclick="addRandomEdge()">Add Random Edge</button>
        <button onclick="resetGraph()">Reset Graph</button>
    </div>
    <canvas id="graphCanvas" width="800" height="600"></canvas>

    <script>
        class FlowchartGraph {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.options = {
                    nodeSize: options.nodeSize || 60,
                    gridSize: options.gridSize || 20,
                    nodeColor: options.nodeColor || '#1a73e8',
                    edgeColor: options.edgeColor || '#666',
                    snapToGrid: options.snapToGrid !== undefined ? options.snapToGrid : true,
                    verticalSpacing: options.verticalSpacing || 100,
                    horizontalSpacing: options.horizontalSpacing || 200
                };

                this.nodes = [];
                this.edges = [];
                this.isDragging = false;
                this.draggedNode = null;

                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }

            addNode(id, x, y) {
                const nodeSize = this.options.nodeSize;
                this.nodes.push({
                    id,
                    x: x || Math.random() * (this.canvas.width - nodeSize * 2) + nodeSize,
                    y: y || Math.random() * (this.canvas.height - nodeSize * 2) + nodeSize,
                    targetX: null,
                    targetY: null
                });
            }

            addEdge(sourceId, targetId) {
                const sourceIndex = this.nodes.findIndex(node => node.id === sourceId);
                const targetIndex = this.nodes.findIndex(node => node.id === targetId);
                
                if (sourceIndex !== -1 && targetIndex !== -1) {
                    this.edges.push({ source: sourceIndex, target: targetIndex });
                }
            }

            snapToGrid(value) {
                const gridSize = this.options.gridSize;
                return Math.round(value / gridSize) * gridSize;
            }

            drawArrow(fromX, fromY, toX, toY) {
                const headLength = 10;
                const headAngle = Math.PI / 6;

                // Calculate the angle of the line
                const angle = Math.atan2(toY - fromY, toX - fromX);

                // Draw the line
                this.ctx.beginPath();
                this.ctx.moveTo(fromX, fromY);

                // Calculate midpoints for orthogonal lines
                const midX = (fromX + toX) / 2;
                const midY = (fromY + toY) / 2;

                // Draw path with right angles
                this.ctx.lineTo(midX, fromY); // Horizontal line
                this.ctx.lineTo(midX, toY);   // Vertical line
                this.ctx.lineTo(toX, toY);    // Horizontal line to end

                // Draw the arrowhead
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(toX - headLength * Math.cos(angle - headAngle),
                              toY - headLength * Math.sin(angle - headAngle));
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(toX - headLength * Math.cos(angle + headAngle),
                              toY - headLength * Math.sin(angle + headAngle));

                this.ctx.stroke();
            }

            updatePositions() {
                const { nodeSize, verticalSpacing, horizontalSpacing } = this.options;

                // Simple layered layout
                const layers = {};
                let maxLayer = 0;

                // Assign initial layers based on incoming edges
                this.nodes.forEach((node, index) => {
                    const incomingEdges = this.edges.filter(e => e.target === index);
                    const layer = incomingEdges.length === 0 ? 0 : 
                        Math.max(...incomingEdges.map(e => (layers[e.source] || 0))) + 1;
                    layers[index] = layer;
                    maxLayer = Math.max(maxLayer, layer);
                });

                // Position nodes based on layers
                const nodesInLayer = new Array(maxLayer + 1).fill(0);
                this.nodes.forEach((node, index) => {
                    const layer = layers[index];
                    const nodesInThisLayer = this.nodes.filter((_, i) => layers[i] === layer).length;
                    const position = nodesInLayer[layer]++;
                    
                    // Calculate target position
                    const targetX = (layer * horizontalSpacing) + nodeSize;
                    const targetY = (position * verticalSpacing) + nodeSize;
                    
                    // Smooth movement
                    node.x += (targetX - node.x) * 0.1;
                    node.y += (targetY - node.y) * 0.1;
                    
                    // Snap to grid if enabled
                    if (this.options.snapToGrid) {
                        node.x = this.snapToGrid(node.x);
                        node.y = this.snapToGrid(node.y);
                    }
                });
            }

            draw() {
                const { nodeSize, nodeColor, edgeColor } = this.options;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.ctx.strokeStyle = '#eee';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.canvas.width; x += this.options.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += this.options.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Draw edges with arrows
                this.ctx.strokeStyle = edgeColor;
                this.ctx.lineWidth = 2;
                this.edges.forEach(edge => {
                    const source = this.nodes[edge.source];
                    const target = this.nodes[edge.target];
                    this.drawArrow(
                        source.x,
                        source.y,
                        target.x,
                        target.y
                    );
                });

                // Draw nodes (squares)
                this.nodes.forEach((node, index) => {
                    // Draw square node
                    this.ctx.fillStyle = nodeColor;
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    const halfSize = nodeSize / 2;
                    this.ctx.beginPath();
                    this.ctx.rect(node.x - halfSize, node.y - halfSize, nodeSize, nodeSize);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Draw label
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(node.id.toString(), node.x, node.y);
                });
            }

            handleMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                const halfSize = this.options.nodeSize / 2;

                this.nodes.forEach((node, index) => {
                    if (x >= node.x - halfSize && x <= node.x + halfSize &&
                        y >= node.y - halfSize && y <= node.y + halfSize) {
                        this.isDragging = true;
                        this.draggedNode = index;
                    }
                });
            }

            handleMouseMove(event) {
                if (!this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                this.nodes[this.draggedNode].x = this.options.snapToGrid ? this.snapToGrid(x) : x;
                this.nodes[this.draggedNode].y = this.options.snapToGrid ? this.snapToGrid(y) : y;
            }

            handleMouseUp() {
                this.isDragging = false;
                this.draggedNode = null;
            }

            start() {
                const animate = () => {
                    this.updatePositions();
                    this.draw();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            clear() {
                this.nodes = [];
                this.edges = [];
            }
        }

        // Initialize graph
        let graph = new FlowchartGraph('graphCanvas', {
            nodeSize: 60,
            gridSize: 20,
            snapToGrid: true,
            verticalSpacing: 100,
            horizontalSpacing: 200
        });

        function setupInitialGraph() {
            // Add initial nodes
            graph.addNode(1, 100, 100);
            graph.addNode(2, 300, 100);
            graph.addNode(3, 500, 200);
            graph.addNode(4, 300, 300);

            // Add initial edges
            graph.addEdge(1, 2);
            graph.addEdge(2, 3);
            graph.addEdge(3, 4);
            graph.addEdge(1, 4);
        }

        function addRandomNode() {
            const newId = graph.nodes.length + 1;
            graph.addNode(newId);
        }

        function addRandomEdge() {
            if (graph.nodes.length < 2) return;
            const sourceIndex = Math.floor(Math.random() * graph.nodes.length);
            let targetIndex;
            do {
                targetIndex = Math.floor(Math.random() * graph.nodes.length);
            } while (targetIndex === sourceIndex);

            graph.addEdge(
                graph.nodes[sourceIndex].id,
                graph.nodes[targetIndex].id
            );
        }

        function resetGraph() {
            graph.clear();
            setupInitialGraph();
        }

        setupInitialGraph();
        graph.start();
    </script>
</body>
</html>